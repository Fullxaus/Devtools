## Результаты само-ревью DVT-9

### Найденные проблемы

#### 1. Отсутствие CI badge в README
**Файл:** README.md (начало файла)
**Проблема:** Нет бейджа статуса сборки GitHub Actions
**Почему важно:** CI badge показывает статус проекта сразу при открытии README —
это стандарт для open-source проектов и упрощает мониторинг состояния сборки.
**Исправление:** Добавить бейдж в начало README:

#### 2. Забыт отладочный вывод
**Файл:** src/main/java/ru/mentee/power/devtools/Demo.java (строка 12)
**Проблема:** Оставлен `System.out.println("Debug: starting loop")`
**Почему важно:** Отладочный вывод замусоривает логи production-приложения и создаёт впечатление небрежности.
**Исправление:** Удалить строку или заменить на logger (если логирование настроено).

#### 3. Закомментированный код
**Файл:** src/main/java/ru/mentee/power/devtools/ProgressLoop.java (строки 23-27)
**Проблема:** Закомментированы 5 строк старой реализации цикла
**Почему важно:** Закомментированный код создаёт путаницу: непонятно зачем он сохранён и актуален ли.
Если нужна история изменений — она в Git.
**Исправление:** Удалить закомментированный код. Если нужна старая версия — посмотреть в Git History.


## Результаты само-ревью DVT-9

### Найденные проблемы

#### 1. Отсутствие CI badge в README
**Файл:** README.md (начало файла)
**Проблема:** Нет бейджа статуса сборки GitHub Actions
**Почему важно:** CI badge показывает статус проекта сразу при открытии README —
это стандарт для open-source проектов и упрощает мониторинг состояния сборки.
**Исправление:** Добавить бейдж в начало README:

#### 2. Забыт отладочный вывод
**Файл:** src/main/java/ru/mentee/power/devtools/Demo.java (строка 12)
**Проблема:** Оставлен `System.out.println("Debug: starting loop")`
**Почему важно:** Отладочный вывод замусоривает логи production-приложения и создаёт впечатление небрежности.
**Исправление:** Удалить строку или заменить на logger (если логирование настроено).

#### 3. Закомментированный код
**Файл:** src/main/java/ru/mentee/power/devtools/ProgressLoop.java (строки 23-27)
**Проблема:** Закомментированы 5 строк старой реализации цикла
**Почему важно:** Закомментированный код создаёт путаницу: непонятно зачем он сохранён и актуален ли.
Если нужна история изменений — она в Git.
**Исправление:** Удалить закомментированный код. Если нужна старая версия — посмотреть в Git History.
----------------------------------------------------------------------------------------------------------------


## Информационный поиск — результаты DVT-11

### Запросы и источники

| № | Запрос | Операторы | Официальный источник | Альтернатива | Статус | Дата проверки |
|---|--------|-----------|----------------------|--------------|--------|---------------|
| 1 |Lombok Gradle Short |  https://projectlombok.org/setup/gradle|https://mvnrepository.com/artifact/io.freefair.gradle/lombok-plugin/8.0.0 | 350к   | 9.12.2025     
| 2 | Java Stream API документация|https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html |https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html | 280к   | 9.12.2025     |
| 3 |горячие клавиши IntelliJ IDEA |https://www.jetbrains.com/help/idea/mastering-keyboard-shortcuts.html |https://otus.ru/nest/post/494/   | 420к          |9.12.2025


### AI-промпты и сравнение ассистентов

Задача: Нужно добавить валидацию email в класс Student
Контекст: Java 25, у меня есть класс Student с полем email (String), проект на Gradle
Ограничения: без использования регулярных выражений на данном этапе, простая проверка наличия @ и точки
Ожидаемый результат: план из 3-5 шагов, объяснение "почему именно так", НЕ пиши код — я реализую сам
Критерии успеха: валидация отклоняет пустые строки, строки без @, строки без точки после @

AI-1 (ChatGPT):

    Проверьте, что строка не пуста.
    Найдите индекс символа '@' в строке.
    Проверьте, что индекс '@' не равен 0 и что после '@' есть точка.

AI-2 (DeepSeek):

    Проверьте, что строка не пуста и содержит '@'.
    Разделите строку на части по '@' и проверьте, что частей ровно 2.
    Проверьте, что вторая часть содержит точку.

#### Промпт 2: Проверка кода

Промпт 2: Проверка кода

Код для проверки:

public String calculateTotalProgress(Mentee[] mentees) {
// Проверка валидности массива
if (mentees == null || mentees.length == 0) {
return "Суммарно: пройдено 0 из 0 уроков, осталось 0 уроков";
}

        // Инициализация аккумуляторов
        int totalCompleted = 0;
        int totalTotal = 0;
        int index = 0;

        // Цикл while для перебора массива
        while (index < mentees.length) {
            totalCompleted += mentees[index].completedLessons();
            totalTotal += mentees[index].totalLessons();
            index++;
        }

        // Вычисление оставшихся уроков
        int totalRemaining = totalTotal - totalCompleted;

        // Возвращение строки с информацией о суммарном прогрессе
        return String.format("Суммарно: пройдено %d из %d уроков, осталось %d уроков", totalCompleted, totalTotal, totalRemaining);
    }

Что проверить:

    Логические ошибки
    Соответствие Code Conventions
    Производительность

AI-1 (Scout):

Анализ

Логические ошибки:

    Не обрабатывается случай, когда mentees содержит null элементы. При вызове mentees[index].completedLessons() или mentees[index].totalLessons() может возникнуть NullPointerException.
    Не проверяется, что totalTotal не меньше totalCompleted. Если это не так, totalRemaining может быть отрицательным.

Соответствие Code Conventions:

    Название метода calculateTotalProgress корректно.
    Переменные totalCompleted, totalTotal, index имеют понятные имена.
    Однако, вместо использования цикла while, можно использовать более идиоматический для Java цикл for.

Производительность:

    Использование цикла while вместо for не критично для производительности, но менее читаемо.

Улучшение кода :

public String calculateTotalProgress(Mentee[] mentees) {
if (mentees == null || mentees.length == 0) {
return "Суммарно: пройдено 0 из 0 уроков, осталось 0 уроков";
}

    int totalCompleted = 0;
    int totalTotal = 0;

    for (Mentee mentee : mentees) {
        if (mentee != null) {
            totalCompleted += mentee.completedLessons();
            totalTotal += mentee.totalLessons();
        }
    }

    int totalRemaining = Math.max(totalTotal - totalCompleted, 0);

    return String.format("Суммарно: пройдено %d из %d уроков, осталось %d уроков", totalCompleted, totalTotal, totalRemaining);
}

AI-2 (Giga chat):

Логические ошибки

Код выглядит правильным с точки зрения базовой логики, однако есть пара моментов, которые стоит учесть:

    Если массив менторов (Mentee) пуст или равен null, вы возвращаете строку "Суммарно: пройдено 0 из 0 уроков, осталось 0 уроков". Это нормально, но возможно стоит подумать над альтернативным сообщением, например: "Нет учеников." или сделать возврат пустого значения, если такая ситуация критична для бизнес-логики.Однако этот выбор зависит от контекста вашего приложения.
    Ваш цикл использует индексный доступ к элементам массива, что совершенно нормально. Но обратите внимание, что современные Java-стили рекомендуют использование цикла for-each или Stream API там, где это уместно и улучшает читаемость кода.

Code Conventions
1. Структура метода:

   Метод объявлен публичным (public), что верно, если он предназначен для внешнего использования. Однако подумайте, насколько нужен именно открытый метод или же разумнее сделать его защищённым (protected) или закрытым (private), если логика предназначена исключительно для внутреннего использования внутри класса.

2. Форматирование:

   Между методами и переменными рекомендуется оставлять одну пустую строку для лучшей визуальной организации кода.
   Блок проверки ввода (if (mentees == null ...)) лучше расположить перед инициализацией всех остальных переменных, чтобы избежать ненужных вычислений, если условие изначально неверно.

3. Нейминг:

   Название метода calculateTotalProgress() вполне соответствует конвенциям именования методов в Java, но оно длинное. Можно рассмотреть сокращение до более лаконичного названия вроде summarizeProgress().
   Переменная index названа правильно, но её объявление можно переместить непосредственно внутрь цикла, что является хорошим стилем современного Java-кода.

Производительность

Производительности тут почти нечего улучшать, так как ваш алгоритм имеет сложность O(n). Вот несколько мелких улучшений:

    Использование цикла for-each сделает код немного чище и избавит вас от ручной манипуляции с индексом:



for (Mentee mentee : mentees) {
totalCompleted += mentee.completedLessons();
totalTotal += mentee.totalLessons();
}

Это изменение незначительно повлияет на производительность, но улучшит читаемость кода.

    Хотя использование строкового формата (String.format(...)) приемлемо, создание строки вручную с использованием конкатенации тоже хороший вариант, особенно если оптимизировать ресурсоемкость:



return "Суммарно: пройдено " + totalCompleted +
" из " + totalTotal + " уроков, осталось " + totalRemaining + " уроков";

Однако, учитывая современный подход к работе со строками в Java, разницы в производительности практически не будет.

Итоговая версия кода:

Вот как может выглядеть обновленный метод с учётом рекомендаций:


public String summarizeProgress(Mentee[] mentees) {
if (mentees == null || mentees.length == 0) {
return "Нет учеников.";
}

    int totalCompleted = 0;
    int totalTotal = 0;

    for (Mentee mentee : mentees) {
        totalCompleted += mentee.completedLessons();
        totalTotal += mentee.totalLessons();
    }

    int totalRemaining = totalTotal - totalCompleted;

    return String.format("Суммарно: пройдено %d из %d уроков, осталось %d уроков",
                         totalCompleted, totalTotal, totalRemaining);
}

Сравнение:
Scout и Giga chat обнаружили логические ошибки и соответствие Code Conventions. 
Оба ИИ предложили свой вариант по улучшению кода.
---------------------------------------------------------------------------------------------------------------------------------------------

1.JDK — Java Development Kit
Определение: Набор инструментов для разработки, тестирования и запуска приложений на Java, включающий компилятор, отладчик и другие утилиты.
Контекст использования: Используется для создания и запуска Java-приложений, а также для разработки и тестирования Java-библиотек и фреймворков.
Пример: java -version — команда для проверки версии JDK, установленной на компьютере.
Источник: https://docs.oracle.com/javase/8/docs/technotes/guides/
2.JRE — Java Runtime Environment
Определение: Набор библиотек и инструментов, необходимых для запуска Java-приложений, включая виртуальную машину Java (JVM).
Контекст использования: Используется для запуска Java-приложений на компьютере, на котором не требуется разработка или тестирование.
Пример: java -jar myapp.jar — команда для запуска Java-приложения с помощью JRE.
Источник: https://docs.oracle.com/javase/8/docs/technotes/guides/
3.JVM — Java Virtual Machine
Определение: Виртуальная машина, которая выполняет байт-код Java, обеспечивая независимость Java-программ от аппаратной платформы.
Контекст использования: Используется для выполнения Java-приложений и обеспечения их взаимодействия с аппаратными ресурсами компьютера.
Пример: java -Xmx1024m myapp.jar — команда для запуска Java-приложения с ограничением на использование памяти.
Источник: https://docs.oracle.com/javase/8/docs/technotes/guides/
4.IDE — Integrated Development Environment
Определение: Интегрированная среда разработки, которая предоставляет набор инструментов для создания, редактирования, компиляции и отладки программного обеспечения.
Контекст использования: Используется для разработки и отладки программного обеспечения, включая Java-приложения.
Пример: Eclipse, IntelliJ IDEA, NetBeans — популярные IDE для разработки Java-приложений.
Источник: https://en.wikipedia.org/wiki/Integrated_development_environment
5.SDK — Software Development Kit
Определение: Набор инструментов, библиотек и документации, необходимых для разработки программного обеспечения для конкретной платформы.
Контекст использования: Используется для разработки программного обеспечения для различных платформ, включая мобильные устройства и операционные системы.
Пример: Android SDK — набор инструментов для разработки приложений для Android.
Источник: https://en.wikipedia.org/wiki/Software_development_kit
6.Gradle Wrapper — Gradle Wrapper
Определение: Утилита, которая позволяет запускать задачи Gradle без необходимости устанавливать Gradle на компьютере.
Контекст использования: Используется для автоматизации процесса сборки и развертывания программного обеспечения.
Пример: ./gradlew build — команда для запуска задачи сборки с помощью Gradle Wrapper.
Источник: https://docs.gradle.org/current/userguide/gradle_wrapper.html
7.Build Tool — Build Tool
Определение: Утилита, которая автоматизирует процесс сборки и развертывания программного обеспечения.
Контекст использования: Используется для автоматизации процесса сборки и развертывания программного обеспечения.
Пример: Maven, Gradle, Ant — популярные build tools.
Источник: https://en.wikipedia.org/wiki/Build_automation
8.Repository — Repository (Git context)
Определение: Хранилище, в котором хранятся все версии codebase и история изменений.
Контекст использования: Используется для управления версиями codebase и сотрудничества между разработчиками.
Пример: git clone https://github.com/user/repo.git — команда для клонирования репозитория.
Источник: https://git-scm.com/docs/gitrepository
9.Commit — Commit
Определение: Действие, которое фиксирует изменения в репозитории.
Контекст использования: Используется для сохранения изменений в репозитории и создания новой версии codebase.
Пример: git commit -m "Fixed bug" — команда для создания коммита.
Источник: https://git-scm.com/docs/git-commit
10.Branch — Branch
Определение: Независимая ветка разработки в репозитории.
Контекст использования: Используется для параллельной разработки и тестирования новых функций.
Пример: git branch feature/new-feature — команда для создания новой ветки.
Источник: https://git-scm.com/docs/git-branch
11.Pull Request — Pull Request
Определение: Запрос на принятие изменений из одной ветки в другую, обычно используемый для ревью и слияния кода.
Контекст использования: Используется для сотрудничества между разработчиками и обеспечения качества кода.
Пример: Создание pull request на GitHub для ревью изменений перед слиянием с основной веткой.
Источник: https://docs.github.com/en/pull-requests
12.Code Review — Code Review
Определение: Процесс анализа и проверки кода на соответствие стандартам, качеству и функциональности.
Контекст использования: Используется для обеспечения качества кода, выявления ошибок и улучшения читаемости.
Пример: Ручной ревью кода коллегой перед слиянием изменений.
Источник: https://en.wikipedia.org/wiki/Code_review
13.CI/CD — CI/CD
Определение: Аббревиатура от "Continuous Integration" и "Continuous Deployment", означающая непрерывную интеграцию и доставку.
Контекст использования: Используется для автоматизации процесса сборки, тестирования и развертывания программного обеспечения.
Пример: Использование Jenkins или GitLab CI/CD для автоматизации процесса сборки и развертывания.
Источник: https://en.wikipedia.org/wiki/CI/CD
14.Checkstyle — Checkstyle
Определение: Инструмент для статического анализа кода на соответствие стандартам и соглашениям.
Контекст использования: Используется для обеспечения качества кода и соблюдения стандартов кодирования.
Пример: Использование Checkstyle для проверки кода на соответствие стандартам Java.
Источник: https://checkstyle.sourceforge.net/
15.Debug — Debug
Определение: Процесс выявления и исправления ошибок в программном обеспечении.
Контекст использования: Используется для выявления и исправления ошибок в коде.
Пример: Использование отладчика для пошагового выполнения кода и выявления ошибок.
Источник: https://en.wikipedia.org/wiki/Debugging
16Breakpoint — Breakpoint
Определение: Точка в коде, где выполнение программы приостанавливается для анализа состояния.
Контекст использования: Используется для отладки кода и выявления ошибок.
Пример: Установка breakpoint в отладчике для приостановки выполнения программы и анализа переменных.
Источник: https://en.wikipedia.org/wiki/Breakpoint


README.md	Основной документационный файл проекта, написанный в формате Markdown. Содержит описание проекта, инструкции по установке и использованию.
Markdown	Лёгкий язык разметки, используемый для форматирования текста в README, документации и комментариях в GitHub.
JavaDoc	Стандарт документирования Java-кода. Генерирует HTML-страницы с описанием классов и методов на основе специальных комментариев в коде.
Issue	Запись о проблеме, задаче или улучшении в системе отслеживания задач (например, GitHub Issues).
Commit Message	Сообщение, описывающее изменения, внесённые в коммите. Хорошее сообщение должно быть понятным и информативным.
Pull Request Description	Описание изменений в Pull Request, объясняющее, что было сделано, почему и как это тестировалось.
